# Понимаем изоляцию глобальных акторов в Swift Concurrency на примере @MainActor

## Введение

Эта статья посвящена важной теме в современной Swift-разработке — глобальным акторам и механизму изоляции, на примере популярного актера `@MainActor`. Мы разберём понятные и практичные примеры, которые помогут вам разобраться с многопоточностью и сделать код ваших приложений безопаснее.

## Что такое глобальные акторы?

Swift Concurrency принесла множество инструментов для управления многопоточностью. Среди них — глобальные акторы, которые помогают обеспечить безопасность данных и контролировать потоки выполнения. Один из самых распространённых и полезных — это `@MainActor`, который гарантирует выполнение операций в главном потоке приложения.

## Примеры использования @MainActor

### 1. Без глобальной изоляции
```swift
protocol IUpdate {
    func update(date: Date) async
}

@Observable
final class LS: IUpdate {}
```
**Вывод:** Без явной изоляции код может исполняться в любых потоках, что может привести к гонкам данных и другим проблемам.

### 2. Полная изоляция на уровне типа
```swift
@MainActor
protocol IUpdate {
    func update(date: Date) async
}

@MainActor
@Observable
final class LS: IUpdate {}
```
**Вывод:** Весь код класса гарантированно исполняется в главном потоке, обеспечивая полную безопасность независимо от места реализации протокола.

### 3. Изоляция одного метода
```swift
@Observable
final class LS: IUpdate {
    @MainActor
    func update(date: Date) async {}
}
```
**Вывод:** Тонкая настройка изоляции конкретного метода позволяет обеспечить безопасность без необходимости полной изоляции класса.

### 4. Изоляция свойства
```swift
@Observable
final class LS: IUpdate {
    @MainActor
    var date: Date = .now
}
```
**Вывод:** Свойство изолировано от параллельных потоков, обеспечивая корректное состояние данных.

### 5. Полная изоляция через протокол
```swift
@MainActor
protocol IUpdate {
    func update(date: Date) async
}

@Observable
final class LS: IUpdate {
    func update(date: Date) async {}
}
```
**Вывод:** Удобный подход, позволяющий гарантировать, что все методы протокола исполняются на главном акторе.

### 6. Частичная изоляция через расширение
```swift
@MainActor
protocol IUpdate {
    func update(date: Date) async
}

@Observable
final class LS {}

extension LS: IUpdate {
    func update(date: Date) async {}
}
```
**Вывод:** Частичная изоляция полезна, когда изолировать требуется лишь конкретные методы.

### 7. Отсутствие изоляции при реализации в другом расширении
```swift
@MainActor
protocol IUpdate {
    func update(date: Date) async
}

@Observable
final class LS {}

extension LS: IUpdate {}

extension LS {
    func update(date: Date) async {}
}
```
**Вывод:** Реализация протокола и методов в разных расширениях нарушает изоляцию, что требует особого внимания при проектировании.

## Итоговые выводы (немного водички)

Используя Swift Concurrency, вы получаете мощные инструменты управления потоками и безопасности данных. Аннотация `@MainActor` позволяет легко и эффективно защитить ваш код от случайных ошибок и гонок данных, особенно если он касается пользовательского интерфейса. Однако важно помнить о том, что подходы к изоляции имеют свои особенности и ограничения. Выбор подходящего варианта зависит от конкретных задач и контекста вашего приложения. Осознавая эти детали, вы сможете писать более надёжный и предсказуемый код, избегая множества распространённых проблем многопоточности.

Надеемся, эта статья поможет вам легко ориентироваться в многопоточности и писать безопасный и надёжный код.

---

**Полезные материалы:**
- [Проект на GitHub](https://github.com/ivalx1s/swift_global-actor-isolation_cases)

**Авторы:**
- Алексей Григорьев, техлид iOS-разработки продукта Membrana (Telegram: @a1exxxis)
- Иван Опарин, друг и коллега (Telegram: @ivanopcode)

